'''
This code was generated by @Sidharth, This code contains the simulation of room and RIRs generated by it

Input : number of sources, number of receivers (mic), mic_pattern, sampling frequency 
Output : RIRs (nb_src*nb_rcv, -1), metadata

usage :
prasim = PRASimulator()
rirs = prasim.RIR() 
#rirs_summed.shape = (nb_src, nb_rcv, fs*T60) 
'''
import torch
import numpy as np
import os
import tqdm
import soundfile as sf
import torchaudio
import numpy.matlib
import matplotlib.pyplot as plt
from math import ceil
import pdb
import time
import gpuRIR
gpuRIR.activateMixedPrecision(False)
gpuRIR.activateLUT(True)


X_min, X_max = 5, 10 # Room length range
Y_min, Y_max = 5, 10 # Room width range
Z_min, Z_max = 3, 4 # Room height range

#RT60_min, RT60_max = 0.15, 1.5 # RT60 range (from inverse sabine formula, rt60 of smallest room ~ 0.1098 s)
RT60_min, RT60_max = 0.15, 1 # RT60 range (from inverse sabine formula, rt60 of smallest room ~ 0.1098 s)

# MIC_H_min, MIC_H_max = 0.9, 1.8 # Microphone height range

# SRC_X_min, SRC_X_max = 0, 10 # Source distance range
# SRC_Y_min, SRC_Y_max = 0, 10 * np.pi # Source angle range
# SRC_Z_min, SRC_Z_max = 0.9, 1.8 # Source height range
SRC_AMPL_MIN, SRC_AMPL_MAX = 0.3, 0.6 # Source amplitude range
class PRASimulator():
    def __init__(self, np_random_state = None, sr=24000):
        if np_random_state is None:
            self.np_rng = np.random.RandomState()
        else:
            self.np_rng = np_random_state

        # Choose rt60
        self.rt60 = self.np_rng.uniform(RT60_min, RT60_max)

        room_dims_compatible = False
        while not room_dims_compatible:
            # Choose room dimensions
            L = self.np_rng.uniform(X_min, X_max)
            W = self.np_rng.uniform(Y_min, Y_max)
            H = self.np_rng.uniform(Z_min, Z_max)
            self.room_dims = np.array([L, W, H])

            # Try getting ISM params using inverse Sabine formula.
            # If not possible, try selecting new room dimensions
            try:
              #gpuRIR.beta_SabineEstimation(self.room_sz, Tself.60, abs_weights=self.abs_weights)
                beta = gpuRIR.beta_SabineEstimation(self.room_dims, self.rt60)
                # self.absorption, self.max_order = pra.inverse_sabine(self.rt60, self.room_dims) #alpha = 0.161V/T60
                room_dims_compatible = True
            except ValueError:
                print("Room is too large for chosen rt60, trying again")

        # Choose microphone position
        #create a square microphone array

        '''            mic1-----------mic2
                        |               |.      source (random pos within the room except inside the mic square)
                        |               |
                        |               |
                        mic3----------mic4
        '''

        #variabilities are nil


        mic_x_1 = 5/4 
        mic_y_1 = 5/4 
        mic_z_1 = 1.8

        mic_x_2 = 3*(5/4) 
        mic_y_2 = 5/4 
        mic_z_2 = 1.8

        mic_x_3 = 5/4 
        mic_y_3 = 3*(5/4) 
        mic_z_3 = 1.8

        mic_x_4 = 3*(5/4) 
        mic_y_4 = 3*(5/4)
        mic_z_4 = 1.8


        self.mic_pos = np.array([[mic_x_1, mic_y_1, mic_z_1],[mic_x_2, mic_y_2, mic_z_2],[mic_x_3, mic_y_3, mic_z_3],[mic_x_4, mic_y_4, mic_z_4]])
        # self.mic_pos = np.array([[mic[0], mic[1], mic[2]] for mic in self.mic_pos]).T


    def choose_random_source_position(self, nb_src=2):
        # Choose source parameters
        # breakpoint()
        source_pos = []
        check = True
        z_min, z_max = min(self.mic_pos[:,2]), max(self.mic_pos[:,2])

        while len(source_pos)!=nb_src:
          x, y, z = self.np_rng.uniform(0, self.room_dims[0]), self.np_rng.uniform(0,self.room_dims[1]), self.np_rng.uniform(0, self.room_dims[2])
          if len(source_pos)>=1:
            if [x,y,z] in source_pos:
              continue
          if self.mic_pos[0][0] <= x <= self.mic_pos[1][0]:
            if self.mic_pos[0][1]<=y<=self.mic_pos[2][1]:
              if z_min<=z<=z_max:
                continue
          source_pos.append([x,y,z])
        return np.array(source_pos)



    def RIR(self):
      self.nb_src=2
      self.pos_src = self.choose_random_source_position(self.nb_src)
      self.nb_rcv = 4
      self.mic_pattern = "omni" # Receiver polar pattern #optinal. :Default omni
      self.T60 = 1.0	 # Time for the RIR to reach 60dB of attenuation [s]
      self.att_diff = 1	# Attenuation when start using the diffuse reverberation model [dB]
      self.att_max = 60.0 # Attenuation at the end of the simulation [dB]
      self.fs= 16000  # Sampling frequency [Hz]
      beta = gpuRIR.beta_SabineEstimation(self.room_dims, self.T60) # Reflection coefficients
      
      Tmax = gpuRIR.att2t_SabineEstimator(self.att_max, self.T60)	 # Time to stop the simulation [s]
      #nb_img = gpuRIR.t2n(Tmax,self.room_dims )	# Number of image sources in each dimension
      nb_img = [10,10,10]
      RIRs = gpuRIR.simulateRIR(self.room_dims, beta, self.pos_src, self.mic_pos, nb_img, Tmax, self.fs, mic_pattern=self.mic_pattern)
      # RIRs_summed = np.sum(RIRs, axis=0)
      # t = np.arange(int(ceil(Tmax * self.fs))) / self.fs
      # plt.plot(t, RIRs.reshape(self.nb_src*self.nb_rcv, -1).transpose())
      # plt.show()
      return torch.from_numpy(RIRs)

if __name__ =='__main__':
  num_rirs=50000
  master_path = "/mmfs1/gscratch/intelligentsystems/common_datasets/spatial_audio_rirs"
  for idx in tqdm.tqdm(range(num_rirs)):
    prasim = PRASimulator()
    rirs = prasim.RIR() 
    for src in range(rirs.shape[0]):
        rir_src_rcv = torch.transpose(rirs[src, :, :],0,1)
        sf.write(f"{master_path}/{idx+1}_{src+1}.wav", rir_src_rcv, 16000)










      